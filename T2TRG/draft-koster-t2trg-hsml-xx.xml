<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.26 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc subcompact="no"?>
<?rfc iprnotified="no"?>

<rfc ipr="trust200902" docName="draft-koster-t2trg-hsml-00" category="exp">

  <front>
    <title>Media Types for Hypertext Sensor Markup</title>

    <author initials="M." surname="Koster" fullname="Michael Koster">
      <organization>SmartThings</organization>
      <address>
        <postal>
          <street>1281 Lawrence Station Road</street>
          <city>Sunnyvale</city>
          <code>94089</code>
          <country>USA</country>
        </postal>
        <phone>+1-707-502-5136</phone>
        <email>michael.koster@smartthings.com</email>
      </address>
    </author>

    <date year="2016" month="July" day="28"/>

    <area>Internet</area>
    <workgroup>Thing-to-Thing Research Group</workgroup>
    <keyword>IoT, T2TRG, Web of Things, Hypermedia, Semantic Interoperability, HATEOAS, Web Linking, CoRE, Constrained Resources, REST, Hyperlinks</keyword>

    <abstract>


<t>The scale and scope of the worldwide web has been in part driven by the availability of HTML as a common serialization, data model, and interaction model for structured resources on the web. By contrast, the general use of appropriate hypermedia techniques for machine interfaces has been limited by the lack of a common markup format for serialization and exchange of structured machine resources and sensor/actuator data which includes or embeds standardized hypermedia controls. The IRTF Thing to Thing Research Group <xref target="T2TRG"/> has a charter to investigate the use of REST design style <xref target="REST"/>for machine interactions. The W3C Web of Things Interest Group <xref target="W3C-WoT"/> are investigating abstract hypermedia controls and interaction models for machines. Machine optimized content formats exist for web links <xref target="RFC5988"/> <xref target="RFC6690"/> and for data items <xref target="I-D.ietf-core-senml"/>.</t>

<t>Structured data which contains both links and items is known as the collection type. This draft describes media types for representation of machine resources structured as collections. A simple, reusable data model is described with a representation format, using a well known set of keywords to expose hypermedia controls, which inform clients how to perform state transfer operations on resources. The underlying assumptions regarding transfer layer processing are specified in this document. The HSML media type described in this document is compatible with SenML and CoRE Link-format by reusing the keyword identifiers and element structures from these content formats. Representations of HSML document content may be obtained in CoRE Link-Format and SenML content formats.</t>



    </abstract>


  </front>

  <middle>


<section anchor="scope" title="Scope of this document">

<t>This is a broadly scoped document which specifies representation formats, data models, interaction models, transfer mapping, URI processing, and design pattern extensions including actions and monitors.</t>

<t>The features listed above and new features may be specified and extended as needed in other documents which refer to this document.</t>

</section>
<section anchor="overview-and-use-case-requirements" title="Overview and Use Case Requirements">

<t>Use case requirements include the following.</t>

<t>A standardized way to expose self-describing resource representations using embedded hyperlinks and link annotations.</t>

<t>A standardized way of organizing and interacting with resource instances using hypermedia controls such as links and forms.</t>

<t>A standardized encapsulation of resources for modeling things, capabilities, groups, indices, and other common structures.</t>

</section>
<section anchor="model" title="Data Model and Interaction Model">

<t>The HSML data model consists of collections containing links which point to items. An instance of a collection is a resource and is identified by a URI.</t>

<t>Links are standard web links as in <xref target="RFC5988"/> or <xref target="RFC6690"/>. Items are identified by links in collections.</t>

<t>Links in a collection may point to items within the context of the collection or they may point to items external to the collection, on the same server or on other servers.</t>

<t>Items are data elements, either within the context the collection, or outide the context of the collection. An instance of an item is a resource and is identified by a URI.</t>

<t>An Item may only be in the context of one collection, but may be identified by any number of links in any number of collections.</t>

<t>Items in the collection that use an HSML compatible data model, for example SenML, see <xref target="I-D.ietf-core-senml"/>, may be embedded in the collection and transferred either along with the links or separately from links.</t>

<section anchor="informative-representation-examples" title="Informative Representation Examples">

<t>JSON formatted examples are used in this document to illustrate normative and informative concepts. Representations in other formats may be derived from the JSON representations. For example, compact binary mappings may be defined using available models.</t>

</section>
<section anchor="links" title="Links">

<t>Links follow the specifications in <xref target="RFC5988"/> and <xref target="RFC6690"/> with extensions to implement actions and monitors as described in this document and any referencing extension documents.</t>

<t>HSML Links may be stored in Resource Directories for discovery using CoRE Resource Directory <xref target="I-D.ietf-core-resource-directory"/>.</t>

</section>
<section anchor="collections" title="Collections">

<t>Collections contain one or more links and extended links, and may contain data items referred to by the links. A representation of a collection may contain both links and data items, plus any extended links such as action forms.</t>

</section>
<section anchor="link-embedding" title="Link Embedding">

<t>Link embedding enables the transfer of one or more items in a collection using a single transfer operation. This document describes two types of link embedding for items in the collection. Batch link embedding allows one or more resource instances (item) to each contribute part of an aggregate (collection) representation. Group link embedding allows a particular operation to be repeated for each member (item) of a group (collection).</t>

<section anchor="batch-operations-on-multiple-items-in-a-collection" title="Batch operations on multiple items in a collection">

<t>A collection of items enables operations on more than one item at a time by exposing a structured a representation of multiple resources in the collection.</t>

<t>Applications may select resources by using URI parameters, and transfer representations of multiple named resources using the HSML or SenML multi-item formats.</t>

</section>
<section anchor="collective-operation-on-groups-of-linked-resources" title="Collective operation on groups of linked resources">

<t>Resource links in the collection may specify group transfer semantics, where transfer operations are routed to each resource in the collection specified by a group link. Group responses are aggregated using a multi-item format which identifies each item by URI.</t>

</section>
</section>
</section>
<section anchor="abstract-transfer-model" title="Abstract Transfer Model">

<t>The HSML media type assumes a transfer model capable of interacting with representations using a simple CRUD model, allowing for basic life cycle operations on resources and collections.</t>

<t><list style="hanging">
  <t hangText='CREATE'><vspace blankLines='0'/>
  Create an instance of a resource as specified using the payload as a constructor. Optionally return a reference to the created resource. Typically uses POST in CoAP <xref target="RFC7252"/> or HTTP, may use PUBLISH in pubsub protocols.</t>
  <t hangText='RETRIEVE'><vspace blankLines='0'/>
  Obtain a representation of the selected resource. Typically uses GET in CoAP or HTTP, could use SUBSCRIBE with message retention in pubsub.</t>
  <t hangText='UPDATE'><vspace blankLines='0'/>
  Replace or partially replace the representation of the selected resource. Typically uses PUT or PATCH in CoAP and HTTP, could use PUBLISH in pubsub in the frequent case that CREATE and UPDATE are not needed on the same resource.</t>
  <t hangText='DELETE'><vspace blankLines='0'/>
  Remove the representation of the selected resource. Typically uses DELETE in CoAP or HTTP. There is no natural mapping to pubsub if a remove operation is not provided.</t>
  <t hangText='OBSERVE'><vspace blankLines='0'/>
  Obtain a sequence of representations of the selected resource, indicating state updates which occur on the resource. Typically uses CoAP Observe, HTTP EventSource, MQTT SUBSCRIBE. OBSERVE is the transfer equivalent of performing a RETRIEVE on the resource immediately following each state change of the resource.</t>
</list></t>

</section>
<section anchor="collection-description" title="Collections">
<t>Collection representations in HSML include Base Elements, Link Elements, and Item Elements.</t>

<section anchor="base-element" title="Base element">
<t>A base elements describes the context under which to interpret values embedded in subsequent items within the representation of a collection.</t>

<t>The base identifier element (bi) may contain an absolute URI or an absolute path reference from which to base relative references found in the links. It functions as a base URI embedded in content as per <xref target="RFC3986"/> Section 5.1.1</t>

<t>URI reference follows the definition in <xref target="RFC3986"/> Section 5.</t>

<t>The format of base elements are specified in <xref target="I-D.ietf-core-senml"/>. <xref target="fig-example-base-identifier"/> is an example of a base  element.</t>

<figure title="Example Base URI" align="left" anchor="fig-example-base-identifier"><artwork><![CDATA[
    {
      "bi": "/sensors/"
    }
]]></artwork></figure>

<t>Other base items from SenML are permissible, including base time (bt) and base value(bv). If additional senml base values are present, the client MUST interpret the items in the collection in the context of the applicable base elements. For example, if there is a “bv” or base value elment, all of the returned values from items in the collection MUST be added to the base value as per <xref target="I-D.ietf-core-senml"/>.</t>

</section>
<section anchor="link-element" title="Link element">
<t>A link element is a hyperlink based on the structure and syntax of <xref target="RFC6690"/> and <xref target="I-D.ietf-core-links-json"/>. An example link element is shown in <xref target="fig-link-element"/>.</t>

<figure title="Example Link Element" align="left" anchor="fig-link-element"><artwork><![CDATA[
    {
      "href": "temp",
      "rt": "some.sensor.temp"
    }
]]></artwork></figure>

</section>
<section anchor="item-element" title="Item element">
<t>An item element in a collection is a data element that is referenced by a link in the collection.</t>

<t>Items in the collection are indicated by hyperlink references (“href”) that serve as selection variables for matching to URI parameters and resource names (“n”)in multi-resource representataions. Reference resolution should use the rules defined in <xref target="RFC3986"/>.</t>

<t>Items may be embedded in the collection, they may be subresources of the collection, or they may be items in other collections referenced by links in the collection. An example item element is shown in <xref target="fig-item-element"/></t>

<figure title="Example Item Element" align="left" anchor="fig-item-element"><artwork><![CDATA[
    {
      "n": "temp",
      "v": 27
    }
]]></artwork></figure>

<section anchor="items-embedded-in-the-collection" title="Items embedded in the collection">
<t>Items may be stored as simple sets of key-value pairs in the context of the collection. Items stored in this way may only offer item representations. Links about these items may be obtained from the collection that contains them.</t>

<figure title="Items Embedded in a Collection" align="left" anchor="fig-example-item"><artwork><![CDATA[
   [ 
     {
       "bi": "/sensors/"
     },
     {
       "href": "temp",
       "rel": "item"
     },
     {
       "href": "humid",
       "rel": "item"
     },
     {
       "n": "temp",
       "v": 27
     },
     {
       "n": "humid",
       "v": 50
     }
   ]
]]></artwork></figure>

</section>
<section anchor="items-stored-as-collections" title="Items stored as collections">
<t>Alternatively, items themselves may be stored as single-item collections, pointed to by links in another collection. Items stored as collections may contain an item with a zero length name, and a self link for the item as shown in the collection representation of the item in <xref target="fig-example-coll-item"/>. Items stored in this way may be augmented by adding additional resources and link content to the collection. Items stored as collections may offer link format and collection format representations.</t>

<figure title="Items as Separate Collections" align="left" anchor="fig-example-coll-item"><artwork><![CDATA[
   base collection:
   [ 
     {
       "bi": "/sensors/"
     },
     {
       "href": "temp/"
     },
     {
       "href": "humid/"
     }   
   ]
   
   "temp" item:
   [ 
     {
       "bi": "/sensors/temp/"
     },
     {
       "rel": ["self","item"]
     },
     {
       "v": 27
     }
   ]
   
   "humid" item:
   [ 
     {
       "bi": "/sensors/humid/"
     },
     {
       "rel": ["self","item"]
     },
     {
       "v": 50
     }
   ]
]]></artwork></figure>

<t>Items embedded in collections, and items linked and stored as separate collections, will all be returned using the item representation format as shown in <xref target="fig-example-senml-item"/>. A client interacting with the items representation of the example collection at /sensors/ would not need to understand the difference between embedded items and linked items that exposed similar content.</t>

<figure title="Example Items Representation" align="left" anchor="fig-example-senml-item"><artwork><![CDATA[
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50 
      }
    ]
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="representation-formats" title="Representation Formats">

<t>The HSML media type includes multiple content types and interface types <xref target="I-D.ietf-core-interfaces"/> to enable the client to select representations that optimize communication for the workflow. Representation formats include links and items together (collection formats), links alone (link formats), or items alone (item formats).</t>

<t>Link formats are useful for discovery workflow, item formats are useful for interaction with resource state machines, and link+item formats are useful for constructing and modifying resource instances.</t>

<t>In addition to HSML native formats, standard CoRE Link-Format <xref target="RFC6690"/> and SenML formats <xref target="I-D.ietf-core-senml"/> may be exposed.</t>

<section anchor="example-formats" title="Example Serialization Formats">
<t><xref target="fig-example-hsml"/> shows an example document in hsml+json format. This example contains a base element, three link elements, and two item elements.</t>

<figure title="Example Collection Format" align="left" anchor="fig-example-hsml"><artwork><![CDATA[
    RETRIEVE /sensors/ accept=application/hsml+json
    or
    RETRIEVE /sensors/ accept=application/hsml.collection+json
    or
    RETRIEVE /sensors/ 
      accept=application/hsml+json?if=hsml.collection
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": "some.sensor.temp"
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

<t>The HSML media type defines content formats and corresponding CoRE Interface Types that may select partial representations of the resource for interaction.</t>

<section anchor="collection-formats" title="Collection Formats">

<t>Collection formats as shown in <xref target="fig-example-hsml"/> expose all of the elements of a resource, including items, links, and link extensions.</t>

</section>
<section anchor="link-formats" title="Link Formats">

<t>Link content formats, when used in an “accept” option or “content-type” option in a transfer header, or when selected by the “if=hsml.link” URI parameter, will select the link elements in the collection for interaction as in <xref target="fig-example-hsml-link"/>.</t>

<figure title="Example Lnk Format" align="left" anchor="fig-example-hsml-link"><artwork><![CDATA[
    RETRIEVE /sensors/ accept=application/hsml.link+json
    or
    RETRIEVE /sensors/ accept=application/hsml+json?if=hsml.link
    Response Payload:
    [
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": "some.sensor.temp"
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      }
    ]
]]></artwork></figure>

<t>CoRE link-format content formats, for example application/link-format+json,  select RFC6690 compliant links, and may not include representations of extended links (rel=action, rel=monitor).</t>

</section>
<section anchor="item-formats" title="Item Formats">

<t>Item content formats, when used in an “accept” option or “content-type” option in a transfer header, or when selected by the “if=hsml.item” URI parameter, will select the item elements in the collection for interaction as in <xref target="fig-example-hsml-item"/>.</t>

<figure title="Example Item Format" align="left" anchor="fig-example-hsml-item"><artwork><![CDATA[
    RETRIEVE /sensors/ accept=application/hsml.item+json
    or
    RETRIEVE /sensors/ accept=application/hsml+json?if=hsml.item
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

<t>URI Parameters for matching link attributes and relations may be used to select items when item representations are being specified using either content-format (accept) or interface parameters (if=). For example:</t>

<figure title="Item Selection Using Link Parameter" align="left" anchor="fig-example-hsml-item-rt"><artwork><![CDATA[
    RETRIEVE /sensors/?if=hsml.item&rt=some.sensor.temp
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 27
      }    
    ]
]]></artwork></figure>

<t>SenML content formats select data records and return SenML compliant resource names. “bn” may optionally be returned when  compliant resource names “n” may be resolved through simple string concatenation as per <xref target="I-D.ietf-core-senml"/>.</t>

</section>
</section>
</section>
<section anchor="uri-and-parameter-processing" title="URI and Parameter Processing">

<t>The HSML media type defines URI reference processing and URI Query processing but does not in general define fragment (#) references in URIs.</t>

<t>If fragment references are provided in a particular transfer implementation, they should be used to select single items in collections in accordance with current practice.</t>

<section anchor="uri-path-processing" title="URI Path Processing">

<t>The path part of the URI reference used to indicate HSML resources may be used as a reference to a collection or to an item in a collection. Collection references should contain the trailing slash character “/” in accordance with <xref target="RFC3986"/>. Server implementations should return links to collections with the trailing “/”, and should attempt to accept references to collections without the trailing “/” if such references can be used to construct unambiguous references.</t>

<t>References to items in a collection should not contain the trailing “/” character. Servers should return items in response to references that do not contain the trailing “/” character, and should attempt to accept references to items in collections with the trailing “/” if such references can be used to construct unambiguous references.</t>

<t>URI references may be routed to collections in the order in which path segments appear in the reference, from left to right reading the path string, separated by “/” characters.</t>

<t>URI references may alternatively be routed as opaque strings to resources. In this case, the resolution of relative references to items in a collection should be possible by concatenating the relative reference to the context URI of the collection. Note that this may enforce certain naming conventions such as the trailing slash in practice.</t>

</section>
<section anchor="uri-parameter-processing" title="URI Parameter processing">

<t>URI Parameters, typically mapped as query parameters in HTTP and CoAP, are used for selecting resources, selecting partial representations, and otherwise modifying aspects of the expected or included representation. In this way, they may be considered part of the URI, since they help identify a unique representation to be transferred.</t>

<section anchor="resource-selection" title="Resource selection">

<t>URI Parameters may be used to select resources in a collection for transfer. This is done using the common parameter matching rules specified in <xref target="RFC6690"/>.</t>

<t>Resource selection is performed based on matching URI Parameters with Link Parameters of all links in the collection which are exposed by the indicated media type and interface type. URI Parameters listed in <xref target="uri-params"/> are excluded from the matching process.</t>

<t>The target resource selection depends on the content-format specified in the request or the interface type specified in the URI parameters.</t>

<t>The collection content-formats or interface types select all links and items in the collection, including link extensions. URI parameters included in the request should be matched against link parameters for selecting links and associated items.</t>

<t>The link content formats or interface types select all links in the collection. URI parameters included in the request should be matched against link parameters for link selection.</t>

<t>The item content formats or interface types select all items in the collection. URI parameters included in the request should be matched against link parameters associated with items in the collection for item selection as shown in <xref target="fig-example-hsml-item-rt"/>.</t>

</section>
</section>
</section>
<section anchor="transfer-model-mapping-to-collections" title="Transfer Model Mapping to Collections">

<section anchor="target-resource-is-collection-format-is-collection" title="Target Resource is Collection, Format is Collection">

<t>When the reference of a request targets a collection resource, using a collection format, the representation may contain both links and items. It is implied that operations using this format will interact with both links and items. The collection format is indicated by using a collection content type in the accept or content-type header, or by specifying a collection interface type e.g. if=hsml.collection.</t>

<section anchor="retrieve" title="RETRIEVE">
<t>Retrieve returns a representation of selected elements, consisting of a list of elements in the collection, including base element, links, and optionally representations of items, as shown in <xref target="fig-example-hsml-retrieve"/>. Elements may include link extenstions, for example action links and monitor links.</t>

<figure title="Retrieve Collection" align="left" anchor="fig-example-hsml-retrieve"><artwork><![CDATA[
    RETRIEVE /sensors/ accept=application/hsml.collection+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": "some.sensor.temp"
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
<section anchor="update" title="UPDATE">
<t>Update replaces all selected elements in the collection with elements included in the payload. Update operations may include replace (PUT) and partial update (PATCH) oprations where supported in the transfer protocol. The server response should indicate that the resource was Changed.</t>

<figure title="Update Item in Collection" align="left" anchor="fig-example-hsml-update"><artwork><![CDATA[
    UPDATE /sensors/?href=temp 
      content-type=application/hsml.collection+json
    Payload:
    [
      {
        "rt": ["some.sensor.temp", "some.other.type"]
      }
    ]
    Response: Changed
    
    RETRIEVE /sensors/ accept=application/hsml.collection+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": ["some.sensor.temp", "some.other.type"]
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
<section anchor="create" title="CREATE">
<t>Create adds elements to a collection, including links and items, where the elements are specified by representations included in the payload. Hints and directives about the created resource may be included in the payload as link parameters, for example a value for href, specifying the location of the created resource. The server is expected to return the location of created resource instances to the client in a header or other response parameter. For example, the “Location” option in CoAP or “Location” header in HTTP should be used to identify the created resource. The server response should indicate that a resource was Created.</t>

<figure title="Create Item in Collection" align="left" anchor="fig-example-hsml-create"><artwork><![CDATA[
    CREATE /sensors/ content-type=application/hsml.collection+json
    Payload:
    [
      {
        "href": "barometer",
        "rt": "some.sensor.mbar"
      },
      {
        "n": "barometer",
        "v": 993
      }
    ]
    Response: Created
    Location: "barometer"
    
    RETRIEVE /sensors/ accept=application/hsml.collection+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "barometer",
        "rt": "some.sensor.mbar"
      },
      {
        "href": "temp",
        "rt": ["some.sensor.temp", "some.other.type"]
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      },
      {
        "n": "barometer",
        "v": 993
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
<section anchor="delete" title="DELETE">
<t>Delete removes selected elements from the collection. If no elements are selected, delete removes the entire collection. The server response should indicate that the resource was Deleted.</t>

<figure title="Delete Item in Collection" align="left" anchor="fig-example-hsml-delete"><artwork><![CDATA[
    DELETE /sensors/?href=barometer
    Response: Deleted
    
    RETRIEVE /sensors/ accept=application/hsml.collection+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": ["some.sensor.temp", "some.other.type"]
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
</section>
<section anchor="target-resource-is-collection-format-is-link" title="Target Resource is Collection, Format is Link">

<t>When a collection is referenced and the link format is indicated, using a link content format in the header or specifying a link interface type, e.g. if=hsml.link, it is expected that the request will interact with the links in the collection.</t>

<section anchor="retrieve-1" title="RETRIEVE">
<t>Retrieve returns a list containing selected links, as shown in <xref target="fig-example-link-retrieve"/>.</t>

<figure title="Retrieve Links" align="left" anchor="fig-example-link-retrieve"><artwork><![CDATA[
    RETRIEVE /sensors/ accept=application/hsml.link+json
    Response Payload:
    [
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": ["some.sensor.temp", "some.other.type"]
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      }
    ]
    
    RETRIEVE /sensors/?rt=some.sensor.temp 
    accept=application/hsml.link+json
    Response Payload:
    [
      {
        "href": "temp",
        "rt": ["some.sensor.temp", "some.other.type"]
      }
    ]
     
]]></artwork></figure>

</section>
<section anchor="update-1" title="UPDATE">
<t>Update modifies selected links, replacing link elements with elements included in the payload. Update operations may include replace (PUT) and partial update (PATCH) oprations where supported in the transfer protocol. The server response should indicate that the resource was Changed.</t>

<figure title="Update Links" align="left" anchor="fig-example-link-update"><artwork><![CDATA[
    UPDATE /sensors/?href=temp 
    content-type=application/hsml.link+json
    Payload:
    [
      {
        "rt": "some.sensor.temp"
      }
    ]
    
    RETRIEVE /sensors/ accept=application/hsml.link+json
    Response Payload:
    [
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": "some.sensor.temp",
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      }
    ]
]]></artwork></figure>

</section>
<section anchor="create-1" title="CREATE">
<t>Create adds links to the collection, where the links are included in the payload. The server response should indicate that the resource was Changed.</t>

<figure title="Create Links" align="left" anchor="fig-example-link-create"><artwork><![CDATA[
    CREATE /sensors/ content-type=application/hsml.link+json
    Payload:
    [
      {
        "href": "/sensor-group/"
      }
    ]
    Response: Changed
    
    RETRIEVE /sensors/ accept=application/hsml.link+json
    Response Payload:
    [
      {
        "href": "/sensor-group/"
      },
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": "some.sensor.temp",
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      }
    ]

]]></artwork></figure>

</section>
<section anchor="delete-1" title="DELETE">
<t>Delete removes selected links from the collection. The server response should indicate that the resource was Changed. If links point to items in the context of the collection, either remove the items as well as the links, or leave the collection as is and return a method error (Method Not Allowed).</t>

<figure title="Delete Links" align="left" anchor="fig-example-link-delete"><artwork><![CDATA[
    DELETE /sensors/?href=sensor-group 
    Response: Changed
   
    RETRIEVE /sensors/ accept=application/hsml.link+json
    Response Payload:
    [
      {
        "anchor": "/sensors/",
        "rel": ["self", "index"]
      },
      {
        "href": "temp",
        "rt": "some.sensor.temp",
      },
      {
        "href": "humid",
        "rt": "some.sensor.humid"
      }
    ]
]]></artwork></figure>

</section>
</section>
<section anchor="target-resource-is-collection-format-is-item" title="Target Resource is Collection, Format is Item">

<t>Whan a collection is referenced and the item format is indicated, either by including an item content type in the request header or using an item interface type, e.g. if=hsml.item, it is expected that the request will interact with the items in a collection.</t>

<t>Specifying item interaction with a collection invokes the link embedding operations.</t>

<section anchor="link-embedding-items" title="Link Embedding Items">

<t>Collective operations on items in collections are invoked by using the URI of the collections, along with URI parameters, to select one or more items in the collection.</t>

<t>Items which are compatible with the HSML item format may be returned with multiple items embedded in a single representation.</t>

</section>
<section anchor="retrieve-2" title="RETRIEVE">
<t>Retrieve returns a list containing a base element and a composite representation of the selected items as shown in <xref target="fig-example-item-retrieve"/>.</t>

<figure title="Retrieve Items" align="left" anchor="fig-example-item-retrieve"><artwork><![CDATA[
    RETRIEVE /sensors/ accept=application/hsml.item+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 27
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
    
    RETRIEVE /sensors/?href=temp 
    accept=application/hsml.item+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 27
      }
    ]
]]></artwork></figure>

</section>
<section anchor="update-2" title="UPDATE">
<t>Update modifies selected items, replacing items in the collection with items included in the payload which match by name “n” value. Update operations may include replace (PUT) and partial update (PATCH) oprations where supported in the transfer protocol. The server response should indicate that the resource was Changed.</t>

<figure title="Update Items" align="left" anchor="fig-example-item-update"><artwork><![CDATA[
    UPDATE /sensors/ content-type=application/hsml.item+json
    Payload:
    [
      {
        "n": "temp",
        "v": 30
      }
    ]
    Response: Changed

    RETRIEVE /sensors/ accept=application/hsml.item+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 30
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
<section anchor="create-2" title="CREATE">
<t>Create adds new items to the collection along with system-constructed links. Link content is determined by the resource type or traits defined by application semantics. Server is expected to return the location of created resource instances to the client in a header or other response parameter. For example, the “Location” option in CoAP or “Location” header in HTTP should be used to identify the created resource. THe server response should indicate that a resource was Created.</t>

<figure title="Create Items" align="left" anchor="fig-example-item-create"><artwork><![CDATA[
    CREATE /sensors/ content-type=application/hsml.item+json
    Payload:
    [
      {
        "n": "barometer",
        "v": 1002
      }
    ]
    Response: Created

    RETRIEVE /sensors/ accept=application/hsml.item+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 30
      },
      {
        "n": "barometer",
        "v": 1002
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
<section anchor="delete-2" title="DELETE">
<t>Delete removes selected items and corresponding links from the collection. The server response should indicate that the resource was Deleted. If no items are selected, return a not found error.</t>

<figure title="Delete Items" align="left" anchor="fig-example-item-delete"><artwork><![CDATA[
    DELETE /sensors/?href=barometer 
    Response: Deleted

    RETRIEVE /sensors/ accept=application/hsml.item+json
    Response Payload:
    [
      {
        "bi": "/sensors/"
      },
      {
        "n": "temp",
        "v": 30
      },
      {
        "n": "humid",
        "v": 50
      }
    ]
]]></artwork></figure>

</section>
</section>
<section anchor="target-resource-is-item" title="Target Resource is Item">

<t>When the URI of a reference points to an item in a collection, it is expected that the request will interact with a single item.</t>

<section anchor="retrieve-3" title="RETRIEVE">
<t>Retrieve returns a representation of the item in the content type according to the accept option of the RETRIEVE request, or using a system defined content-format if there is no accept option provided.</t>

<figure title="Retrieve One Item" align="left" anchor="fig-example-one-item-retrieve"><artwork><![CDATA[
    RETRIEVE /sensors/temp accept=text/plain
    Response Payload:
    30    
]]></artwork></figure>

</section>
<section anchor="update-3" title="UPDATE">
<t>Update replaces the resource state with the state defined in the supplied representation according to the content-type or ct option. Update operations may include replace (PUT) and partial update (PATCH) oprations where supported in the transfer protocol. The server response should indicate that the resource was Changed.</t>

<figure title="Update One Item" align="left" anchor="fig-example-one-item-update"><artwork><![CDATA[
    UPDATE /sensors/temp content-type=text/plain
    Payload:
    33    
    
    RETRIEVE /sensors/temp accept=text/plain
    Response Payload:
    33   
]]></artwork></figure>

</section>
<section anchor="create-3" title="CREATE">
<t>Not Defined, application dependent.</t>

</section>
<section anchor="delete-3" title="DELETE">
<t>Delete removes any links to the item from the collection, and removes the item. If the item is stored as a collection, delete removes the collection. The server response should indicate that the resource was Deleted.</t>

<figure title="Delete One Item" align="left" anchor="fig-example-one-item-delete"><artwork><![CDATA[
    DELETE /sensors/temp 
    
    RETRIEVE /sensors/temp accept=text/plain
    Response: Not Found
]]></artwork></figure>

</section>
</section>
<section anchor="groups" title="Groups">

<t>Group transfer operations are provided by collections that contain links with the “grp” relation value.</t>

<t>Transfer operations which specify the collection URI as target and use the item content format are routed to the resolved URI of each link in the collection that contains the “grp” relation.</t>

<t>URI Parameters used for resource selection and matching are sent to the target URIs of all links that contain the “grp” relation.</t>

<t>Responses from the selected group resources are aggregated and by default returned as a single response. The group response SHOULD be returned as an outer array where such representation is available, for example a JSON array which contains elements consisting of SenML responses.</t>

<t>Optionally, a chunked response may be specified, if provided by the transfer implementation, in which the response from each group member is returned individually within a sequence of responses.</t>

<t>The return code should be based on successful responses from link targets. An implementation of a group collection may choose to allow some rejected responses from link targets, depending on the composition of the link targets. A group may not be required to be composed of link targets that always accept all requests; this is at the discretion of the resource designer.</t>

<t>No mechanism is provided in this document to enable a client to inspect the separate return codes from each group link target resource. Multiple transfer headers may be supplied in some representations, or mapped to metadata in others.</t>

<t>The following examples assume the prior example from <xref target="fig-example-coll-item"/> indexed by a group collection as in <xref target="fig-example-hsml-grp"/>.</t>

<figure title="Example Group Collection" align="left" anchor="fig-example-hsml-grp"><artwork><![CDATA[
    RETRIEVE /sensor-group/ accept=application/hsml.collection+json
    Response Payload:
    [
      {
        "bi": "/sensor-group/"
      },
      {
        "anchor": "/sensor-group/",
        "rel": ["self", "index"]
      },
      {
        "href": "/sensors/temp/",
        "rel": "grp"
      },
      {
        "href": "/sensors/humid/",
        "rel": "grp"
      }
    ]
]]></artwork></figure>

<section anchor="retrieve-4" title="RETRIEVE">
<t>Retrieve requests are routed to each link in the collection that contains the “grp” relation. The response from each link target is returned as an element in an array representation.</t>

<figure title="Group Retrieve" align="left" anchor="fig-example-hsml-grp-retrieve"><artwork><![CDATA[
    RETRIEVE /sensor-group/ accept=application/hsml.item+json
    Response Payload:
    [
      [
        {
          "bi": "/sensors/temp/"
        },
        {
          "v": 33
        }
      ],
      [
        {
          "bi": "/sensors/humid/"
        },
        {
          "v": 41
        }
      ]
    ]
]]></artwork></figure>

</section>
<section anchor="update-4" title="UPDATE">
<t>Update requests are routed to each link in the collection that contains the “grp” relation. The target resource of each group link processes the request, including URI parameters and content format. The result code returned should indicate that the resource is Changed if any resource state may have been updated.</t>

<figure title="Group Update" align="left" anchor="fig-example-hsml-grp-update"><artwork><![CDATA[
    UPDATE /sensor-group/ content-type=application/hsml.item+json
    Payload:
    [
      {
        "v": 0
      }
    ]
    Response: Changed
    
    RETRIEVE /sensor-group/ accept=application/hsml.item+json
    Response Payload:
    [
      [
        {
          "bi": "/sensors/temp/"
        },
        {
          "v": 0
        }
      ],
      [
        {
          "bi": "/sensors/humid/"
        },
        {
          "v": 0
        }
      ]
    ]
]]></artwork></figure>

</section>
<section anchor="create-4" title="CREATE">
<t>Create requests are routed to each link in the collection that contains the “grp” relation. In the example shown in <xref target="fig-example-hsml-grp-create"/>, an additional named resource is being created within each (collection type) item to hold a location value for that item. The result code should indicate that a resource was Created if any resource was created as a result of the create operation.</t>

<figure title="Group Create" align="left" anchor="fig-example-hsml-grp-create"><artwork><![CDATA[
    CREATE /sensor-group/ content-type=application/hsml.item+json
    Payload:
    [
      {
        "n": "location",
        "vs": "living room"
      }
    ]
    Response: Created
    
    RETRIEVE /sensor-group/ accept=application/hsml.item+json
    Response Payload:
    [
      [
        {
          "bi": "/sensors/temp/"
        },
        {
          "v": 0
        },
        {
          "n": "location",
          "vs": "living room"
        }

      ],
      [
        {
          "bi": "/sensors/humid/"
        },
        {
          "v": 0
        },
        {
          "n": "location",
          "vs": "living room"
        }
      ]
    ]
]]></artwork></figure>

</section>
<section anchor="delete-4" title="DELETE">
<t>Delete requests are routed to each link in the collection that contains the “grp” relation. In the example shown in <xref target="fig-example-hsml-grp-delete"/>, the URI parameter ?href=location selects the resource at the relative URI reference “location” at each group link target for delete. The result code should indicate that a resource was Deleted if any resource was deleted as a result of the delete operation.</t>

<figure title="Group Delete" align="left" anchor="fig-example-hsml-grp-delete"><artwork><![CDATA[
    DELETE /sensor-group/?href=location 
    Response: Deleted
    
    RETRIEVE /sensor-group/ accept=application/hsml.item+json

    Response Payload:
    [
      [
        {
          "bi": "/sensors/temp/"
        },
        {
          "v": 0
        }
      ],
      [
        {
          "bi": "/sensors/humid/"
        },
        {
          "v": 0
        }
      ]
    ]

]]></artwork></figure>

</section>
</section>
</section>
<section anchor="link-extensions" title="Link extensions">

<section anchor="actions" title="Actions">

<t>Actions are hypermedia controls, indicated by a rel=action value in a link, used to construct transfer operations that change the state of resources. The use roughly follows the use of forms in HTML <xref target="RFC1866"/>, with semantics more consistent with links. See <xref target="action-params"/> for more information.</t>

<t>An example Action element is shown in <xref target="fig-action-element"/>.</t>

<figure title="Example Action Element" align="left" anchor="fig-action-element"><artwork><![CDATA[
    {
      "rel": "action",
      "type": "st.on",
      "href": "commands",
      "method": "create",
      "accept": "application/json",
      "schema": {"value": "on"}
    }
]]></artwork></figure>

<t>This Action element informs the client that to perform a type “st.on” action on the context resource, perform a CREATE method on the “commands” URI relative to the context URI, using the application/json content type, with a payload as defined by the “Schema” parameter.</t>

</section>
<section anchor="monitors" title="Monitors">

<t>Monitors are hypermedia controls, indicated by a rel=monitor value in a link, used to construct transfer operations that expose state changes of resources. A monitor invokes an outbound transfer operation on a target resource. Monitors use the IANA registered link relation “monitor”, defined in <xref target="RFC5989"/>.</t>

<t>Monitors have a set of accept parameters that indicate how the context resource is being observed, a set of filter parameters that indicate the conditions for generating a state change in the monitor, and a set of target parameters that indicate how state changes are to be applied to the monitor resource. See <xref target="monitor-params"/> for more information.</t>

<t>An example Monitor element is shown in <xref target="fig-monitor-element"/>.</t>

<figure title="Example Monitor Element" align="left" anchor="fig-monitor-element"><artwork><![CDATA[
    {
      "rel": "monitor",
      "href": "tank-level-events",
      "content-type": "application/senml+json",
      "target-method": "create",
      "pmin": 600,
      "pmax": 3600,
      "nbul": 20,
      "nbll": 80
    }
]]></artwork></figure>

<t>This Monitor element defines a monitor resource at the “tank-level-events” URI relative to the context URI, which OBSERVEs the context URI, and updates the “tank-level-events” resource using the CREATE method to add JSON items to the collection, according to the given conditional parameters no more frequently than once every 600 seconds, at least once every 3600 seconds, when the reading is in the notification band, which has a lower limit of 80 and wraps around zero to an upper limit of 20. This has the effect of defining a low level alert notification and high level alert notification.</t>

</section>
</section>
<section anchor="reserved-identifiers" title="Reserved Identifiers">

<t>This section defines the common reserved identifiers that are expected to be processed by implementations of HSML clients and servers. There are many more relation types and link parameters defined and registered with IANA. Implementations should not restrict processing to the keywords identified in this document; they should accept all IANA registered keywords as valid identifiers.</t>

<t>Many of the keywords listed are defined in other RFCs and IETF documents. This document does not redefine any existing keywords. Where a definition exists, the existing definition will be used. Where multiple conflicting definitions exist, this document will indicate the required definition.</t>

<t>New definitions are summarized in <xref target="iana-cons"/>.</t>

<section anchor="default-curie" title="Default CURIE">

<t>Identifiers in representations using the HSML media types are assumed to use the default CURIE “hsml”. An identifier that is not matched to an existing namespace is assumed to carry the prefix “hsml”.</t>

<t>For example, if the identifier “method” is encountered and it doesn’t resolve to an IANA registered parameter (reg-parameter in <xref target="RFC5988"/>) resolution should be attempted using “hsml:method”.</t>

<t>The default CURIE “hsml” identifies a namespace defined by the identifiers in <xref target="reserved-identifiers"/> of this document.</t>

</section>
<section anchor="uri-params" title="URI Processing Parameters">

<t>The following URI Parameters are used to filter representations according to specific processing rules and should not be used to attempt to match link parameters.</t>

<t><list style="hanging">
  <t hangText='“if”'>
  Interface type, used to select a partial representation of a collection</t>
  <t hangText='“count”'>
  Indicates the number of items to be returned from the collection</t>
  <t hangText='“start”'>
  Indicates the array index of the item in the collection to select as the first item to be returned</t>
  <t hangText='“page”'>
  Page number, in units of count</t>
</list></t>

</section>
<section anchor="link-keywords" title="Link Keywords">
<t>The following keywords are reserved for use in an HSML serialization to indicate elements of a web link</t>

<t><list style="hanging">
  <t hangText='“anchor”'><vspace blankLines='0'/>
  Overrides the default resource context of the link</t>
  <t hangText='“rel”'><vspace blankLines='0'/>
  Link relation type as defined in <xref target="RFC5988"/> and <xref target="RFC6690"/></t>
  <t hangText='“href”'><vspace blankLines='0'/>
  Target of a link reference. This may be a relative path reference in the collection, e.g. “currentValue” or an absolute path reference on the server, “/sensors/temp/currentValue”, or an absulute URI, for example  “https://example.com/sensors/temp/currentValue”</t>
</list></t>

<section anchor="link-relation-types" title="Link Relation Types">
<t>The following keywords are reserved for use in a HSML serialization to indicate types of link relations, and are used for values of “rel”.</t>

<t><list style="hanging">
  <t hangText='“self”'><vspace blankLines='0'/>
  Refers to the collection that contains the link</t>
  <t hangText='“item”'><vspace blankLines='0'/>
  The link points to an item in the collection</t>
  <t hangText='“grp”'><vspace blankLines='0'/>
  The item the link points to is available for collective interaction through the collection URI according to group semantics described in <xref target="groups"/>.</t>
</list></t>

</section>
<section anchor="link-attribute-types" title="Link Attribute Types">
<t>The following keywords are reserved for use in a HSML serialization to indicate types of link attributes</t>

<t><list style="hanging">
  <t hangText='“rt”'><vspace blankLines='0'/>
  The resource type(s) of the item</t>
  <t hangText='“u”'><vspace blankLines='0'/>
  Units of measure</t>
  <t hangText='“ct”'><vspace blankLines='0'/>
  The CoAP content-format number(s) associated with the item</t>
  <t hangText='“content-type”'><vspace blankLines='0'/>
  The media type string(s) associated with the item</t>
  <t hangText='“obs”'><vspace blankLines='0'/>
  Presence of this attribute indicates that the associated resource is observable</t>
</list></t>

</section>
</section>
<section anchor="item-keywords" title="Item Keywords">
<t>The following keywords are reserved for use in a HSML serialization to indicate elements within the serialization. Some of these are defined in <xref target="I-D.ietf-core-senml"/>.</t>

<t><list style="hanging">
  <t hangText='“bi”'><vspace blankLines='0'/>
  The base URI of the collection, relative to the service location e.g. “/sensors/temp/” Thi sis a new definition for HSML</t>
  <t hangText='“bt”'><vspace blankLines='0'/>
  The base time that corresponds to the encapsulated state of the collection</t>
  <t hangText='“t”'><vspace blankLines='0'/>
  The time stamp that corresponds to the encapsulated state of the item in the collection, relative to the base time “bt”</t>
  <t hangText='“n”'><vspace blankLines='0'/>
  The name or URI of the resource, relative to the base name or base URI</t>
  <t hangText='“u”'><vspace blankLines='0'/>
  Units of measure</t>
  <t hangText='“v”'><vspace blankLines='0'/>
  Number value</t>
  <t hangText='“vb”'><vspace blankLines='0'/>
  Boolean value</t>
  <t hangText='“vs”'><vspace blankLines='0'/>
  String value</t>
</list></t>

</section>
<section anchor="action-params" title="Link Parameters used in Actions">

<t><list style="hanging">
  <t hangText='“anchor”'><vspace blankLines='0'/>
  May override the default context of an action</t>
  <t hangText='“rel”'><vspace blankLines='0'/>
  Indicates that this control is an action when rel contains the value “action”</t>
  <t hangText='“href”'><vspace blankLines='0'/>
  URI for mapping or invoking the action specified in the action control.</t>
  <t hangText='“type”'><vspace blankLines='0'/>
  Additional indicator of the action being exposed, can be used with “rel”</t>
  <t hangText='“method”'><vspace blankLines='0'/>
  Transfer method to use on a particular action</t>
  <t hangText='“accept”'><vspace blankLines='0'/>
  The Content-Types or CoAP content-formats that are accepted on create and update methods</t>
  <t hangText='“content-type”'><vspace blankLines='0'/>
  The media type string(s) that are exposed by retrieve and observe methods</t>
  <t hangText='“ct”'><vspace blankLines='0'/>
  The CoAP content-format number(s) exposed</t>
  <t hangText='“schema”'><vspace blankLines='0'/>
  Indicates the schema to use for constructing or interpreting transfer payloads, may be a literal value or a URI pointing to an instance of a schema</t>
</list></t>

</section>
<section anchor="monitor-params" title="Link Parameters used in Monitors">

<t><list style="hanging">
  <t hangText='“anchor”'><vspace blankLines='0'/>
  May override the context URI of a monitor with any observable resource</t>
  <t hangText='“rel”'><vspace blankLines='0'/>
  Indicates that this control is a monitor when rel contains the value “monitor”</t>
  <t hangText='“href”'><vspace blankLines='0'/>
  The URI of the resource used to monitor context URI, where transfer operations will be sent.</t>
  <t hangText='“accept”'><vspace blankLines='0'/>
  The media type string or CoAP content-format to request from the observed resource</t>
  <t hangText='“content-type”'><vspace blankLines='0'/>
  The media type string to use in the transfer operation</t>
  <t hangText='“ct”'><vspace blankLines='0'/>
  the CoAP content-format number to use in the transfer operation</t>
  <t hangText='“accept-method”'><vspace blankLines='0'/>
  Transfer method to use in request from the observed resource, default is OBSERVE</t>
  <t hangText='“target-method”'><vspace blankLines='0'/>
  Transfer method to use for notifications, default is UPDATE</t>
  <t hangText='“accept-schema”'><vspace blankLines='0'/>
  Schema to use in interpreting the observed resource payload, required if target-schema is used.</t>
  <t hangText='“target-schema”'><vspace blankLines='0'/>
  Schema to use in constructing the notification transfer payload, default is to transfer the accepted payload unmodified to the target resource.</t>
</list></t>

</section>
<section anchor="conditional-observe-parameters-used-in-monitors" title="Conditional Observe Parameters used in Monitors">

<t><list style="hanging">
  <t hangText='“pmin”'><vspace blankLines='0'/>
  Minimum time between notifications from a monitor</t>
  <t hangText='“pmax”'><vspace blankLines='0'/>
  Maximum time between notifications from a monitor</t>
  <t hangText='“gt”'><vspace blankLines='0'/>
  Value to match or exceed to determine notification condition</t>
  <t hangText='“lt”'><vspace blankLines='0'/>
  Value to match or be less than to determine notification condition</t>
  <t hangText='“st”'><vspace blankLines='0'/>
  Value change +/- from last report to determine notification condition</t>
  <t hangText='“eq”'><vspace blankLines='0'/>
  Value to match, or change from, to determine notification condition</t>
  <t hangText='“nbll”'><vspace blankLines='0'/>
  Defines a lower limit, at or above which notification is enabled</t>
  <t hangText='“nbul”'><vspace blankLines='0'/>
  Defines an upper limit, at or below which notification is enabled</t>
  <t hangText='“init”'><vspace blankLines='0'/>
  Starts the notification state machine with an initial value</t>
</list></t>

</section>
<section anchor="link-attribute-values" title="Link Attribute Values">
<t>The following keywords are reserved for use in a HSML serialization to indicate values of link attributes</t>

<t><list style="hanging">
  <t hangText='“create”'><vspace blankLines='0'/>
  Transfer layer CREATE operation, value of “method” or “target-method”</t>
  <t hangText='“retrieve”'><vspace blankLines='0'/>
  Transfer layer RETRIEVE operation, value of “method” or “accept-method”</t>
  <t hangText='“update”'><vspace blankLines='0'/>
  Transfer layer UPDATE operation, value of “method” or “target-method”</t>
  <t hangText='“delete”'><vspace blankLines='0'/>
  Transfer layer DELETE operation, value of “method” or “target-method”</t>
  <t hangText='“observe”'><vspace blankLines='0'/>
  Transfer layer OBSERVE operation, value of “method” or “accept-method”</t>
</list></t>

</section>
</section>
<section anchor="iana-cons" title="IANA Considerations">

<section anchor="new-media-types" title="New Media Types">

<t>Type</t>

<t><list style="symbols">
  <t>application</t>
</list></t>

<t>Subtypes</t>

<t><list style="symbols">
  <t>hsml</t>
  <t>hsml.collection</t>
  <t>hsml.link</t>
  <t>hsml.item</t>
</list></t>

<t>Media type strings</t>

<t><list style="symbols">
  <t>application/hsml</t>
  <t>application/hsml.collection</t>
  <t>application/hsml.link</t>
  <t>application/hsml.item</t>
  <t>application/hsml+json</t>
  <t>application/hsml.collection+json</t>
  <t>application/hsml.link+json</t>
  <t>application/hsml.item+json</t>
</list></t>

</section>
<section anchor="new-core-parameters-content-formats" title="New CoRE Parameters Content Formats">

<t>(subject to Structured Syntax encoding rules TBD)</t>

<t><list style="symbols">
  <t>22000 - application/hsml+json</t>
  <t>22001 - application/hsml.link+json</t>
  <t>22002 - application/hsml.item+json</t>
</list></t>

</section>
<section anchor="new-link-parameters" title="New Link Parameters">

<t><list style="symbols">
  <t>method</t>
  <t>schema</t>
  <t>content-type</t>
  <t>ct</t>
  <t>accept-method</t>
  <t>target-method</t>
  <t>accept-schema</t>
  <t>target-schema</t>
</list></t>

<t>The following should be registered in the CoRE dynamic linking draft <xref target="I-D.groves-core-dynlink"/>.</t>

<t><list style="symbols">
  <t>pmin</t>
  <t>pmax</t>
  <t>nbll</t>
  <t>nbul</t>
  <t>init</t>
  <t>lt</t>
  <t>gt</t>
  <t>st</t>
  <t>eq</t>
</list></t>

</section>
<section anchor="new-link-relation-types" title="New Link Relation Types">

<t><list style="symbols">
  <t>grp</t>
</list></t>

</section>
<section anchor="new-core-interface-types" title="New CoRE Interface Types">

<t><list style="symbols">
  <t>hsml.collection</t>
  <t>hsml.item</t>
  <t>hsml.link</t>
</list></t>

</section>
<section anchor="transfer-layer-methods" title="Transfer Layer Methods">
<t>These definitions may use the default CURIE and do not need to be registered with IANA</t>

<t><list style="symbols">
  <t>hsml:create</t>
  <t>hsml:retrieve</t>
  <t>hsml:update</t>
  <t>hsml:delete</t>
  <t>hsml:observe</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="object-signing" title="Object Signing">
<t>Collection representations are resource state encapsulations and may be transmitted and stored as signed objects in order to protect the integrity of data and metadata, including time and embedded access control information.</t>

</section>
<section anchor="signed-embedded-time-stamps" title="Signed Embedded Time Stamps">
<t>The collection may include time stamps (bt and t) that are signed with the object data and metadata.</t>

</section>
<section anchor="signed-embedded-access-control" title="Signed Embedded Access Control">
<t>The collection representation may include embedded access control information, also signed with the metadata, that can instruct the server to enforce a particular access policy for transfer requests.</t>

</section>
<section anchor="secure-state-updates" title="Secure State Updates">
<t>Representations submitted to a server to update the state of a resource (UPDATE, CREATE, DELETE) may also contain embedded signed assertions which may be used by the server to decide whether to apply or reject the update.</t>

</section>
<section anchor="object-signing-and-encryption" title="Object Signing and Encryption">
<t>Object signing and encryption SHOULD use the mechanisms specified in IETF documents for secure JSON Objects <xref target="RFC7516"/> and CBOR Objects <xref target="I-D.ietf-cose-msg"/> <xref target="I-D.selander-ace-object-security"/>.</t>

</section>
</section>
<section anchor="terminology" title="Terminology">

<t><list style="hanging">
  <t hangText='Client'><vspace blankLines='0'/>
  Having a client role in a REST operation, transmitting a request and receiving one or more responses.</t>
  <t hangText='Server'><vspace blankLines='0'/>
  Having a server role in a REST operation, the origin of data items or proxy for the origin. A server is also an authority for a URI namespace <xref target="RFC3986"/>.</t>
  <t hangText='Resource'><vspace blankLines='0'/>
  Server endpoint for a REST operation, identified by a URI <xref target="RFC3986"/></t>
  <t hangText='Representation'><vspace blankLines='0'/>
  An encoded form of the state of a resource. The encoding rules may be specified in a media type or content type. Clients and servers exchange representations of resources in order to effect application state changes <xref target="REST"/>.</t>
  <t hangText='URI'><vspace blankLines='0'/>
  Uniform Resource Identifier, used to identify a resource in a link or as a reference <xref target="RFC3986"/></t>
  <t hangText='Reference'><vspace blankLines='0'/>
  An identifier used to select or identify a particular resource. References are constructed by clients to identify resources when interacting with servers. Servers match references in client requests against URIs of hosted resources.</t>
  <t hangText='Media Type, also Content-Format, Content-Type'><vspace blankLines='0'/>
  A set of rules for encoding, transfer, and prosessing resource representations</t>
  <t hangText='Hypermedia'><vspace blankLines='0'/>
  Design style which uses metadata in the form of hyperlinks to structure resources in relation to each other</t>
  <t hangText='Collection'><vspace blankLines='0'/>
  A composite resource that contains links and optionally data items</t>
  <t hangText='Link, also Hyperlink'><vspace blankLines='0'/>
  A metadata element as described in <xref target="RFC5988"/> and <xref target="RFC6690"/> that contains a pointer to and description of some data element.</t>
  <t hangText='Item'><vspace blankLines='0'/>
  A data item pointed to by one or more links in one or more collections.</t>
  <t hangText='Context'><vspace blankLines='0'/>
  The context of a link is the subject of the link or the enclosing scope. In this document the collection is the default context for links in the collection.</t>
  <t hangText='Target'><vspace blankLines='0'/>
  The target of a link is the resource being pointed to or described. Links in a collection point to and describe items as link targets.</t>
  <t hangText='Transfer Layer'><vspace blankLines='0'/>
  A set of predefined message types used to implement state transfer semantics, for example REST.</t>
  <t hangText='Request'><vspace blankLines='0'/>
  A message sent from a client to a server identifying the resource, representation, and method to use for the interaction with the server.</t>
  <t hangText='Response'><vspace blankLines='0'/>
  A message sent from a server to a client in response to a request, which communicates the state of the identified resource.</t>
  <t hangText='Operation or Method'><vspace blankLines='0'/>
  The state transition type requested by the client for the server to perform on the identified resource. Indicated by the transfer layer method, for example, RETRIEVE, UPDATE, CREATE, DELETE.</t>
  <t hangText='Pubsub'><vspace blankLines='0'/>
  A transfer layer semantic interface based on the publish-subscribe paradigm, allowing for asynchronous messages to be routed on demand.</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Informative References'>





<reference  anchor='RFC6690' target='http://www.rfc-editor.org/info/rfc6690'>
<front>
<title>Constrained RESTful Environments (CoRE) Link Format</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<date year='2012' month='August' />
<abstract><t>This specification defines Web Linking using a link format for use by constrained web servers to describe hosted resources, their attributes, and other relationships between links.  Based on the HTTP Link Header field defined in RFC 5988, the Constrained RESTful Environments (CoRE) Link Format is carried as a payload and is assigned an Internet media type.  &quot;RESTful&quot; refers to the Representational State Transfer (REST) architecture.  A well-known URI is defined as a default entry point for requesting the links hosted by a server.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6690'/>
<seriesInfo name='DOI' value='10.17487/RFC6690'/>
</reference>



<reference anchor='I-D.ietf-core-links-json'>
<front>
<title>Representing CoRE Formats in JSON and CBOR</title>

<author initials='K' surname='Li' fullname='Kepeng Li'>
    <organization />
</author>

<author initials='A' surname='Rahman' fullname='Akbar Rahman'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>JavaScript Object Notation, JSON (RFC7159) is a text-based data format which is popular for Web based data exchange.  Concise Binary Object Representation, CBOR (RFC7049) is a binary data format which has been optimized for data exchange for the Internet of Things (IoT).  For many IoT scenarios, CBOR formats will be preferred since it can help decrease transmission payload sizes as well as implementation code sizes compared to other data formats.  Web Linking (RFC5988) provides a way to represent links between Web resources as well as the relations expressed by them and attributes of such a link.  In constrained networks, a collection of Web links can be exchanged in the CoRE link format (RFC6690).  Outside of constrained environments, it may be useful to represent these collections of Web links in JSON, and similarly, inside constrained environments, in CBOR.  This specification defines a common format for this.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-links-json-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-links-json-06.txt' />
</reference>



<reference  anchor='RFC3986' target='http://www.rfc-editor.org/info/rfc3986'>
<front>
<title>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='T. Berners-Lee'><organization /></author>
<author initials='R.' surname='Fielding' fullname='R. Fielding'><organization /></author>
<author initials='L.' surname='Masinter' fullname='L. Masinter'><organization /></author>
<date year='2005' month='January' />
<abstract><t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='66'/>
<seriesInfo name='RFC' value='3986'/>
<seriesInfo name='DOI' value='10.17487/RFC3986'/>
</reference>



<reference  anchor='RFC5988' target='http://www.rfc-editor.org/info/rfc5988'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2010' month='October' />
<abstract><t>This document specifies relation types for Web links, and defines a registry for them.  It also defines the use of such links in HTTP headers with the Link header field.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5988'/>
<seriesInfo name='DOI' value='10.17487/RFC5988'/>
</reference>



<reference  anchor='RFC5989' target='http://www.rfc-editor.org/info/rfc5989'>
<front>
<title>A SIP Event Package for Subscribing to Changes to an HTTP Resource</title>
<author initials='A.B.' surname='Roach' fullname='A.B. Roach'><organization /></author>
<date year='2010' month='October' />
<abstract><t>The Session Initiation Protocol (SIP) is increasingly being used in systems that are tightly coupled with Hypertext Transport Protocol (HTTP) servers for a variety of reasons.  In many of these cases, applications can benefit from being able to discover, in near real- time, when a specific HTTP resource is created, changed, or deleted. This document proposes a mechanism, based on the SIP Event Framework, for doing so.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5989'/>
<seriesInfo name='DOI' value='10.17487/RFC5989'/>
</reference>



<reference  anchor='RFC7252' target='http://www.rfc-editor.org/info/rfc7252'>
<front>
<title>The Constrained Application Protocol (CoAP)</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='K.' surname='Hartke' fullname='K. Hartke'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t><t>CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t></abstract>
</front>
<seriesInfo name='RFC' value='7252'/>
<seriesInfo name='DOI' value='10.17487/RFC7252'/>
</reference>



<reference  anchor='RFC7516' target='http://www.rfc-editor.org/info/rfc7516'>
<front>
<title>JSON Web Encryption (JWE)</title>
<author initials='M.' surname='Jones' fullname='M. Jones'><organization /></author>
<author initials='J.' surname='Hildebrand' fullname='J. Hildebrand'><organization /></author>
<date year='2015' month='May' />
<abstract><t>JSON Web Encryption (JWE) represents encrypted content using JSON-based data structures.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries defined by that specification.  Related digital signature and Message Authentication Code (MAC) capabilities are described in the separate JSON Web Signature (JWS) specification.</t></abstract>
</front>
<seriesInfo name='RFC' value='7516'/>
<seriesInfo name='DOI' value='10.17487/RFC7516'/>
</reference>



<reference  anchor='RFC1866' target='http://www.rfc-editor.org/info/rfc1866'>
<front>
<title>Hypertext Markup Language - 2.0</title>
<author initials='T.' surname='Berners-Lee' fullname='T. Berners-Lee'><organization /></author>
<author initials='D.' surname='Connolly' fullname='D. Connolly'><organization /></author>
<date year='1995' month='November' />
<abstract><t>This document defines a HTML 2.0 (to distinguish it from the previous informal specifications).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='1866'/>
<seriesInfo name='DOI' value='10.17487/RFC1866'/>
</reference>



<reference anchor='I-D.ietf-core-interfaces'>
<front>
<title>Reusable Interface Definitions for Constrained RESTful Environments</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='M' surname='Vial' fullname='Matthieu Vial'>
    <organization />
</author>

<author initials='M' surname='Koster' fullname='Michael Koster'>
    <organization />
</author>

<author initials='C' surname='Groves' fullname='Christian Groves'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>This document defines a set of reusable REST resource design patterns suitable for use in constrained environments, based on IETF CoRE standards for information representation and information exchange.  Interface types for Sensors, Actuators, Parameters, and resource Collections are defined using the "if" link attribute defined by CoRE Link Format [RFC6690].  Clients may use the "if" attribute to determine how to consume resources.  Editor's note: This version removes the observe notify functionality. Further work is needed on this draft to</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-interfaces-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-interfaces-05.txt' />
</reference>



<reference anchor='I-D.ietf-core-resource-directory'>
<front>
<title>CoRE Resource Directory</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='M' surname='Koster' fullname='Michael Koster'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='P' surname='Stok' fullname='Peter Van der Stok'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>In many M2M applications, direct discovery of resources is not practical due to sleeping nodes, disperse networks, or networks where multicast traffic is inefficient.  These problems can be solved by employing an entity called a Resource Directory (RD), which hosts descriptions of resources held on other servers, allowing lookups to be performed for those resources.  This document specifies the web interfaces that a Resource Directory supports in order for web servers to discover the RD and to register, maintain, lookup and remove resources descriptions.  Furthermore, new link attributes useful in conjunction with an RD are defined.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-resource-directory-08' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-resource-directory-08.txt' />
</reference>



<reference anchor='I-D.ietf-core-senml'>
<front>
<title>Media Types for Sensor Markup Language (SenML)</title>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='J' surname='Arkko' fullname='Jari Arkko'>
    <organization />
</author>

<author initials='A' surname='Keranen' fullname='Ari Keranen'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>This specification defines media types for representing simple sensor measurements and device parameters in the Sensor Markup Language (SenML).  Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), eXtensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model.  A simple sensor, such as a temperature sensor, could use this media type in protocols such as HTTP or CoAP to transport the measurements of the sensor or to be configured.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-senml-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-senml-02.txt' />
</reference>



<reference anchor='I-D.ietf-cose-msg'>
<front>
<title>CBOR Object Signing and Encryption (COSE)</title>

<author initials='J' surname='Schaad' fullname='Jim Schaad'>
    <organization />
</author>

<date month='July' day='25' year='2016' />

<abstract><t>Concise Binary Object Representation (CBOR) is data format designed for small code size and small message size.  There is a need for the ability to have the basic security services defined for this data format.  This document defines the CBOR Object Signing and Encryption (COSE) specification.  This specification describes how to create and process signature, message authentication codes and encryption using CBOR for serialization.  This specification additionally specifies how to represent cryptographic keys using CBOR.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-cose-msg-15' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-cose-msg-15.txt' />
</reference>



<reference anchor='I-D.groves-core-dynlink'>
<front>
<title>Dynamic Resource Linking for Constrained RESTful Environments</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='M' surname='Vial' fullname='Matthieu Vial'>
    <organization />
</author>

<author initials='M' surname='Koster' fullname='Michael Koster'>
    <organization />
</author>

<author initials='C' surname='Groves' fullname='Christian Groves'>
    <organization />
</author>

<date month='July' day='6' year='2016' />

<abstract><t>For CoAP [RFC7252] Dynamic linking of state updates between resources, either on an endpoint or between endpoints, is defined with the concept of Link Bindings.  This document defines conditional observation attributes that work with Link Bindings or with simple CoAP Observe [RFC7641].</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-groves-core-dynlink-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-groves-core-dynlink-00.txt' />
</reference>



<reference anchor='I-D.selander-ace-object-security'>
<front>
<title>Object Security of CoAP (OSCOAP)</title>

<author initials='G' surname='Selander' fullname='Goeran Selander'>
    <organization />
</author>

<author initials='J' surname='Mattsson' fullname='John Mattsson'>
    <organization />
</author>

<author initials='F' surname='Palombini' fullname='Francesca Palombini'>
    <organization />
</author>

<author initials='L' surname='Seitz' fullname='Ludwig Seitz'>
    <organization />
</author>

<date month='July' day='7' year='2016' />

<abstract><t>This memo defines Object Security of CoAP (OSCOAP), a method for application layer protection of message exchanges with the Constrained Application Protocol (CoAP), using the CBOR Object Signing and Encryption (COSE) format.  OSCOAP provides end-to-end encryption, integrity and replay protection to CoAP payload, options, and header fields, as well as a secure binding between CoAP request and response messages.  The use of OSCOAP is signaled with the CoAP option Object-Security, also defined in this memo.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-selander-ace-object-security-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-selander-ace-object-security-05.txt' />
</reference>


<reference anchor="REST" target="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">
  <front>
    <title>Architectural Styles and the Design of Network-based Software Architectures</title>
    <author initials="R." surname="Fielding" fullname="Roy Thomas Fielding">
      <organization>University of California, Irvine</organization>
    </author>
    <date year="2000"/>
  </front>
  <seriesInfo name="Ph.D." value="Dissertation, University of California, Irvine"/>
  <format type="PDF" target="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf"/>
</reference>
<reference anchor="W3C-WoT" target="https://www.w3.org/WoT/IG/">
  <front>
    <title>W3C Web of Things Interest Group</title>
    <author initials="." surname="WoT IG">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
</reference>
<reference anchor="T2TRG" target="https://datatracker.ietf.org/rg/t2trg/charter/">
  <front>
    <title>IRTF Thing to Thing Research Group</title>
    <author initials="." surname="IRTF">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
</reference>


    </references>




  </back>
</rfc>

